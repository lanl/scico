# Copyright (C) 2020-2022 by SCICO Developers
# All rights reserved. BSD 3-clause License.
# This file is part of the SCICO package. Details of the copyright and
# user license can be found in the 'LICENSE' file distributed with the
# package.

"""Miscellaneous linear operator definitions."""


# Needed to annotate a class method that returns the encapsulating class;
# see https://www.python.org/dev/peps/pep-0563/
from __future__ import annotations

import operator
from functools import partial
from typing import Optional, Union

import scico.numpy as snp
from scico._autograd import linear_adjoint
from scico.numpy import BlockArray
from scico.numpy.util import ensure_on_device, indexed_shape, is_nested
from scico.operator._operator import _wrap_mul_div_scalar
from scico.typing import ArrayIndex, BlockShape, DType, JaxArray, Shape

from ._linop import LinearOperator, _wrap_add_sub

__all__ = [
    "Diagonal",
    "Identity",
    "Slice",
]


class Diagonal(LinearOperator):
    """Diagonal linear operator."""

    def __init__(
        self,
        diagonal: Union[JaxArray, BlockArray],
        input_shape: Optional[Shape] = None,
        input_dtype: Optional[DType] = None,
        **kwargs,
    ):
        r"""
        Args:
            diagonal: Diagonal elements of this linear operator.
            input_shape:  Shape of input array. By default, equal to
               `diagonal.shape`, but may also be set to a shape that is
               broadcast-compatiable with `diagonal.shape`.
            input_dtype: `dtype` of input argument. The default,
               ``None``, means `diagonal.dtype`.
        """

        self.diagonal = ensure_on_device(diagonal)

        if input_shape is None:
            input_shape = self.diagonal.shape

        if input_dtype is None:
            input_dtype = self.diagonal.dtype

        if isinstance(diagonal, BlockArray) and is_nested(input_shape):
            output_shape = (snp.empty(input_shape) * diagonal).shape
        elif not isinstance(diagonal, BlockArray) and not is_nested(input_shape):
            output_shape = snp.broadcast_shapes(input_shape, self.diagonal.shape)
        elif isinstance(diagonal, BlockArray):
            raise ValueError("`diagonal` was a BlockArray but `input_shape` was not nested.")
        else:
            raise ValueError("`diagonal` was a not BlockArray but `input_shape` was nested.")

        super().__init__(
            input_shape=input_shape,
            input_dtype=input_dtype,
            output_shape=output_shape,
            output_dtype=input_dtype,
            **kwargs,
        )

    def _eval(self, x):
        return x * self.diagonal

    @partial(_wrap_add_sub, op=operator.add)
    def __add__(self, other):
        if self.diagonal.shape == other.diagonal.shape:
            return Diagonal(diagonal=self.diagonal + other.diagonal)
        raise ValueError(f"Incompatible shapes: {self.shape} != {other.shape}")

    @partial(_wrap_add_sub, op=operator.sub)
    def __sub__(self, other):
        if self.diagonal.shape == other.diagonal.shape:
            return Diagonal(diagonal=self.diagonal - other.diagonal)
        raise ValueError(f"Incompatible shapes: {self.shape} != {other.shape}")

    @_wrap_mul_div_scalar
    def __mul__(self, scalar):
        return Diagonal(diagonal=self.diagonal * scalar)

    @_wrap_mul_div_scalar
    def __rmul__(self, scalar):
        return Diagonal(diagonal=self.diagonal * scalar)

    @_wrap_mul_div_scalar
    def __truediv__(self, scalar):
        return Diagonal(diagonal=self.diagonal / scalar)


class Identity(Diagonal):
    """Identity operator"""

    def __init__(
        self, input_shape: Union[Shape, BlockShape], input_dtype: DType = snp.float32, **kwargs
    ):
        """
        Args:
            input_shape: Shape of input array.
        """
        super().__init__(diagonal=snp.ones(input_shape, dtype=input_dtype), **kwargs)

    def _eval(self, x: Union[JaxArray, BlockArray]) -> Union[JaxArray, BlockArray]:
        return x

    def __rmatmul__(self, x: Union[JaxArray, BlockArray]) -> Union[JaxArray, BlockArray]:
        return x


class Slice(LinearOperator):
    """A linear operator for slicing an array."""

    def __init__(
        self,
        idx: ArrayIndex,
        input_shape: Union[Shape, BlockShape],
        input_dtype: DType = snp.float32,
        jit: bool = True,
        **kwargs,
    ):
        r"""
        This operator may be applied to either a :any:`JaxArray` or a
        :class:`.BlockArray`. In the latter case, parameter `idx` must
        conform to the
        :ref:`BlockArray indexing requirements <blockarray_indexing>`.

        Args:
            idx: An array indexing expression, as generated by
                :data:`numpy.s_`, for example.
            input_shape: Shape of input :any:`JaxArray` or :class:`.BlockArray`.
            input_dtype: `dtype` for input argument.
                Defaults to ``float32``. If this LinearOperator implements
                complex-valued operations, this must be ``complex64`` for
                proper adjoint and gradient calculation.
            jit: If ``True``, jit the evaluation, adjoint, and gram
               functions of the LinearOperator.
        """

        output_shape: Union[Shape, BlockShape]
        if is_nested(input_shape):
            output_shape = input_shape[idx]  # type: ignore
        else:
            output_shape = indexed_shape(input_shape, idx)

        self.idx: ArrayIndex = idx
        super().__init__(
            input_shape=input_shape,
            output_shape=output_shape,
            input_dtype=input_dtype,
            output_dtype=input_dtype,
            jit=jit,
            **kwargs,
        )

    def _eval(self, x: JaxArray) -> JaxArray:
        return x[self.idx]



class Crop(LinearOperator):
    """A linear operator for cropping an array."""

    def __init__(
        self,
        crop_width: Union[int, Sequence],
        input_shape: Shape,
        input_dtype: DType = snp.float32,
        jit: bool = True,
        **kwargs,
    ):
        r"""
        Args:
            crop_width: Specify the crop width using the same format as
                the `pad_width` parameter of :func:`snp.pad`.
            input_shape: Shape of input :any:`JaxArray.
            input_dtype: `dtype` for input argument.
                Defaults to ``float32``. If this LinearOperator implements
                complex-valued operations, this must be ``complex64`` for
                proper adjoint and gradient calculation.
            jit: If ``True``, jit the evaluation, adjoint, and gram
               functions of the LinearOperator.
        """

        self.crop_width = crop_width
        # The crop function is defined as the adjoint of snp.pad
        pad = lambda x : snp.pad(x, pad_width=crop_width)
        # The output shape of this operator is the input shape of the corresponding
        # pad operation of which it is the adjoint. Since we don't know this output
        # shape, we assume that it can be computed by subtracting the difference in
        # output and input shapes resulting from applying the pad operator to the
        # input shape of this operator.
        tmp = pad(snp.zeros(input_shape, dtype=input_dtype))
        output_shape = tuple(2 * snp.array(input_shape) - snp.array(tmp.shape))
        pad_adjoint = linear_adjoint(pad, snp.zeros(output_shape, dtype=input_dtype))
        super().__init__(
            input_shape=input_shape,
            input_dtype=input_dtype,
            eval_fn=lambda x: pad_adjoint(x)[0],
            output_shape=output_shape,
            output_dtype=input_dtype,
            jit=jit,
            **kwargs,
        )
